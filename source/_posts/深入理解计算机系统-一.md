---
title: 深入理解计算机系统(一)
tags:
  - 计算机基础
categories: 计算机基础
abbrlink: 33669
date: 2020-07-04 15:08:34
---

刚参加工作时，喜欢追求一些很炫的技法和tricky的表达，但是工作时间久了以后，经常感觉知识不够用，这才发现，大学里那些枯燥无味的基础理论知识才是最值得学习的，这些曾经被我们不屑一顾的东西需要被重新拾起。

<!-- more -->

这篇文章重新学习计算机系统的信息表示和处理，学习资料为《深入理解计算机系统》，第2版，2011年出版。

###二进制信号（bit）

现代计算机存储和处理的信息是以二值信号表示，这些二值信号（即二进制数字）称为bit，或位。计算机使用二进制表示法，是因为对计算机而言，二值信号更容易被表示、存储和传输，就像人类有10根手指，使用十进制表示法更自然。

### 字节（byte）

bit是计算机的最小信息表示单位，但是计算机在存储信息时，使用8 bit的块作为最小的可寻址单位，一个8 bit的块，称为一个字节，即byte。

对计算机程序而言，整个内存被视为一个非常大的byte数组，数组中的每个byte都有一个唯一的数字来标识，称为它的地址，即address。这个只对计算机程序可见的byte数组称为虚拟存储器，虚拟存储器中的所有可能的地址集合称为虚拟地址空间。

###十六进制表示法（0x|0X）

计算机以byte为单位来寻址。byte在二进制表示法中，其值域为00000000 ~ 11111111，在十进制表示法中，其值域为0 ~ 255，这两种表示法在计算机程序中的描述非常不方便，二进制表示法太冗长，十进制表示法与bit的相互转换又很麻烦，所以一个常见的替代方法，使用十六进制表示法来表示bit。

十六进制表示法使用数字0 ~ 9，以及字符 A ~ F来表示16个可能的值，其值域为 00 ~ FF。一个十六进制数的字符部分既可大写，也可以小写，甚至混合写，只要它以0x或oX开头。

十六进制的每个数值都可以使用4个二进制数值来表示。把一个十六进制数值转换为二进制时，直接把数值的每个部分直接转换为二进制，然后把转换后的所有二进制数值拼接在一起，就是它的二进制形式；反过来，把二进制数值转换为十六进制时，直接把每4个二进制数分一组，按分组分别转换，然后把转换后的所有十六进制数拼接在一起，就是它的十六进制形式。若二进制数的位数不是4的倍数时，最左边的一组可以少于4个，前面用0补足。

###数据大小（size）

计算机以byte单位来寻址，所以cpu和编译器都有支持处理字节的指令，不但有单字节的指令，还有双字节、4字节、8字节的指令。这里的数据大小，指的是某种数据类型被分配的字节数，即数据类型的字节表示，而非该数据类型所表示的具体数值大小。

计算机为不同的数据类型分配了不同的字节数，而某一数据类型的准确字节数受限于具体的计算机和编译器。比如一个指针，在32位机器上的长度为4，即一个指针被分配了4个字节，而在64位机器上其长度为8，意味着一个指针要占用8个字节。

C语言使用运算符sizeof来确定某个对象使用的字节数，具体用法为sizeof(T)。对于同一个对象，在不同机器上执行sizeof，其返回值也是不同的。题外话，golang中提供了unsafe.sizeof方法实现的同样的功能。

###大端法和小端法（big endian|little endian）

对于单字节数据类型而言，计算机寻址时可以直接定位到具体地址，但是现代计算机中使用越来越多的多字节对象，那么计算机必须有一套规则来决定：1）这些字节在存储时如何排列， 2）对象的地址如何表示。

几乎所有的机器上，多字节对象都是被存储为连续的字节序列，对象的地址使用这些字节中的最小地址。假设一个int类型的变量占用4个字节，其地址为&0x100，那么这个变量被存储在0x100、0x101、0x102、0x103的位置。

那么变量的值是按何种顺序存储在这4个位置的呢？继续刚才的示例，假设这个变量的十六进制数为0x01234567，其排列顺序根据机器的不同，有如下两种方式：

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  01   |  23   |  45   |  67   | ...  |

|      | 0x100 | 0x101 | 0x102 | 0x103 |      |
| :--: | :---: | :---: | :---: | :---: | :--: |
| ...  |  67   |  45   |  23   |  01   | ...  |

示例变量中，0x01为高位字节，0x67为低位字节。第一种方式高位在前，低位在后，称为大端法，第二种方式高位在后，低位在前，称为小端法。

###文本编码

无论是使用二进制还是十六进制来表示计算机字符，对人类而言可读性都比较差，而且在不同类型的机器上的字节顺序也不一样。高级语言屏蔽了底层的细节，使用人类更易于使用的文本来表示计算机字符。

C语言中，每个人类可读的字符都由某个标准编码来表示，最常见的是ASCII字符码，比如英文字母a，它的ASCII码为ox61。无论任何类型的计算机平台，只要它使用ASCII码作为编码，那么同一个变量的返回值都是相同的，文本数据具备更强的平台独立性。

ASCII码适合英文，但是对于像中文、俄文、希腊文，其包含的字符集数量不是英文所能比拟的，ASCII码根本不够用，所以使用了各自不同的独立编码。为了通用性考虑，Unicode联合会修订了一个复杂且被广为接受的文字编码标准，即Unicode编码，该编码支持的语言范围广泛。

UTF-8作为Unicode的一个分支，提高了Unicode的编码效率，减少了内存空间的浪费，是当前使用最多的一种编码方式。

###布尔代数与位运算

布尔代数起源于1850年前后的乔治.布尔的工作，他注意到将逻辑值True和False编码为1和0，能够设计出一种代数，用于研究逻辑推理的基本原则。到今天，围绕着0和1已经深化出丰富的数学知识体系。

布尔代数的内容不再复述在这里。

C语言使用布尔运算符支持了一种特性：按位布尔运算，具体如下：

```c
OR： 按位或，运算符为 |
AND：按位与，运算符为 &
NOT：按位取反，运算符为 ~
XOR：按位异或，运算符为 ^
```

### 逻辑运算

C语言提供了一组逻辑运算符，分别对应命题逻辑中的OR、AND、NOT，具体如下：

```C
OR： 或，运算符为 ||
AND：与，运算符为 &&
NOT：非，运算符为 !
```

逻辑运算符与位运算符容易混淆，但是他们是完全不同的东西。

###移位运算

C语言中，移位运算有两种：左移和右移。

左移：对于一个操作数x，左移k位，即丢弃最高的k位（最左的k位），并在最右端补充k个0

右移：有两种，一种是逻辑右移，一种是算术右移

逻辑右移与左移类似，丢弃最低的k位，并在最左端补充k个0；而算术右移补同样丢弃最低的k位，但是左端补充的不是0，而是操作数的最高有效位。算术右移适用于有符号整数。

对于右移，C语言中并没有明确定义使用哪个类型的右移，但是几乎所有的编译器都对有符号数使用算术右移，对无符号数使用逻辑右移。

移位运算常用于优化整数运算。大多数机器上，整数的乘法运算和除法运算都比较慢，而加法、减法、位运算、移位运算比较快。一般而言，乘法需要10个或者更多的时钟周期，除法需要30个或者更多的时钟周期，而其它几种运算，只需要一个时钟周期，所以编译器经常会使用移位运算来优化运算速度。



















