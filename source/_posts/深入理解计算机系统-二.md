---
title: 深入理解计算机系统(二)
tags:
  - 计算机基础
categories: 计算机基础
abbrlink: 17185
date: 2020-07-17 00:12:21
---

本篇为《深入理解计算机系统》学习笔记的第2篇：整数。

<!-- more -->

我们很熟悉整数在数学属性上的表示，小学就已经接触过了，但是现在我们把视线转向计算机，看计算机是如何使用位向量来编码和定义整数的，这将为我们打开一个完全不同的世界。

[第一篇笔记](https://liqinshan.github.io/posts/33669/) 中已经讲过，数据类型的长度（数据大小）受字长影响而有差异。64位系统上，C语言整形数据类型的典型取值范围如下：

<img src="/images/int.jpg" alt="整形数据类型大小">

从图中可以看出，负数的范围比正数的范围大1，这跟它的位编码方式有关，涉及到原码、反码、补码的概念和原理。

### 整数的分类：有符号数与无符号数

C和C++对有符号整数和无符整号数都支持，默认为有符号整数，Java只支持有符号整数。

### 整数的位编码方式：原码、反码、补码

数学计算中的整数有正数、0、负数，计算机同样要能够表示正数、0、负数 ，但是它的底层只有二进制的0和1，如何使用位向量来表示符号呢？

为了能够表示正数和负数，计算机使用一个bit的符号位0或1来表示正号（+）或负号（-），符号位放在数值二进制形式的最高位，并且计算机设计了多种编码方式来实现位向量到整数的映射，重要的几个编码方式：原码、补码、反码。

书中在这部分内容中有大量的原理和公式，我们抛开复杂的原理和公式，对于原码、反码、补码的定义，简单概括说就是：

```c
正数的原码、反码、补码都是它自己
负数的原码是它自己；
负数的反码：符号位不变，其余各位取反
负数的补码：符号位不变，其余各位取反，最后末位加1，即在反码的基础上末位加1

数字    原码         反码         补码
+1     0000 0001    0000 0001    0000 0001
-1     1000 0001    1111 1110    1111 1111 
```

计算机为什么使用这些编码方式来表示有符号整数呢？是为了减少电路设计的复杂度，提高运算的速度，它把符号位也作为数值直接参与运算，但是由于符号位并不是真正的数值，所以才有了这些编码方式，方便转换和运算。

当某些场景需要使用负数值时，对有符号整数使用的最常见编码形式就是补码。有趣的是，C语言并没有要求使用哪种方式来表示有符号整数，但是几乎所有的机器都是这么做的；而在Java语言中，明确要求采用补码来表示整数。

对于无符号数而言，仅当被看作是位的集合而没有任何数字意义时，无符号数才是非常有用的，比如往一个数值中放入各种布尔条件的标记（flag）。地址同样如此，也是无符号的。

#### 有符号数和无符号数之间的转换

抛开复杂的原理和公式，计算机是从向量位的角度看待整数的，在有符号数和无符号数之间进行转换时，底层的位表示不变，但是位解释可能发生了变化（表示符号的最高位有可能发生变化），所以值有可能会发生；

C语言中，有符号数到无符号数的隐式强制转换有可能会导致错误或者漏洞，避免这类错误的一种方法是绝不使用无符号数。

#### 不同字长的整数之间的转换

将一个较小的类型转换成一个较大的类型比较简单，无符号数使用零扩展运算，补码数字执行符号扩展。但是从较大类型转换为较小类型时，需要截断。简单说，将一个w位的数字截断为k位数字时，我们会丢弃最高的w-k位。

对于w位的无符号数x而言，截断到k位，相当于计算x mod 2<sup>k</sup>。在整数运算中会用到截断。

### 扩展阅读：图示计算机为什么使用补码表示整数

| <img src="/Users/lqs/pp/liqinshan.github.io/source/images/原码.png" alt="原码" style="zoom:48%;" /> | <img src="/Users/lqs/pp/liqinshan.github.io/source/images/补码.png" alt="补码" style="zoom:48%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                        整数的原码表示                        |                        整数的补码表示                        |

计算机使用的整数默认为有符号数。如果使用原码表示有符号数，如上图（左）所示，运算时会有两个问题：

```
0有两种编码方式
1 +（-1）的结果不为0
```

换成补码方式进制编码，如上图（右）所示，就可以解决上述两个问题。

### 整数运算

整数运算无非加减乘除，但是计算机把整数视为向量位，它的四则运算方式与我们常规认知上的四则运算会有不同。计算机中的整数运算面临着溢出的问题，常见的现象：两个正数相加，结果却为负数。

#### 无符号加法 

假设两个非负整数x、y，都是w位，其取值范围满足：$0 <= x, y <= 2^w -1$，那么，它们两者之和的取值范围满足：0 <= x + y <= 2<sup>w+1</sup>​ - 2，意味着，这个和可能需要w+1位。

以此类推，w+1位的整数相加，其和可能需要w+2位，这种现象意味着，要想完整表达算术运算的结果，就不能对它的长度做任何限制。但是在实际操作中，我们不可能让它无限膨胀，常规做法是截断。

举例如下：

考虑两个4位的整数x、y，其值分别为9、12，其位向量分别是1001、1100，对两个整数进制加法运算，其值为21，位向量需要5位表示，为10101，丢掉最高位1，结果为101，即5，而5恰好是21 mod 2<sup>4</sup> 的结果，所以，无符号整数的加法实际是一种模运算。

再看个示例：

开篇提到过，无符号short类型的整数的取值范围是0 ~ 65535，假设整数x的值为65535，那么x + 1的值是多少？答案是0。原因是，x+1的结果65536超出了2<sup>16</sup> - 1的取值范围，对其进制取模运算：65536 mod 2<sup>16</sup>，结果为0。

#### 补码加法 

 抛开公式，直接上结论：补码表示的是有符号整数，两个w位的有符号整数进行加法运算，其结果的取值范围也可能需要w+1位向量来表示，所以同样需要截断。但是与无符号加法不同的是，补码的溢出可能为正溢出，也可能为负溢出，所以补码加法的结果可能有3种：

<img src="/Users/lqs/pp/liqinshan.github.io/source/images/补码加法.jpg" alt="补码加法" style="zoom:80%;" />

实际上，补码加法是先按照无符号加法进制运算，然后进制无符号和有符号的转换，最终得到结果。

#### 乘法与除法

与加法类似，并且计算机一般会做特别的优化，使用加法运算和移位运算来替代，提高运算速度。

### 关于整数运算的最后思考

计算机执行的整数运算，实际上是一种模运算形式。表示数字的有限字长限制了值的可能取值范围，运算结果可能溢出。

上面这句话，是书中本章节的最后思考，但是我的最后思考是：大概明白了溢出是怎么回事，细节上还是有点迷糊。最后给出酷壳的一篇文章链接 ，比较老了，讲的就是[《C语言的整形溢出问题》](https://coolshell.cn/articles/11466.html)

